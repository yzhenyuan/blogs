# Vue 中的 DOM-Diff

在 Vue 中，把 DOM-Diff 过程叫做**patch 过程**（核心）。patch,意为“补丁”，即指对旧的 VNode 修补，打补丁从而得到新的 VNode。

总之一句话：以新的 VNode 为基准，改造旧的 oldVNode 使之成为跟新的 VNode 一样，这就是 patch 过程要干的事。

整个 patch 无非就是干三件事：

- 创建节点：新的 VNode 中有而旧的 oldVNode 中没有，就在旧的 oldVNode 中创建。
- 删除节点：新的 VNode 中没有而旧的 oldVNode 中有，就从旧的 oldVNode 中删除。
- 更新节点：新的 VNode 和旧的 oldVNode 中都有，就以新的 VNode 为准，更新旧的 oldVNode

<!-- ## vue 中对节点更新的优化 -->
## diff的具体过程
1. 先标记新、旧节点的开始和结束位置
2. 进行循环处理节点
   1. 新节点数组中第一个节点和旧数组中的第一个节点对比，相同，直接用新节点复用老节点，进行 patchVNode 复用
   2. 不同：新数组里面的最后一个节点和旧数组里的最后一个节点对比，相同，直接用新节点复用老节点
   3. 不同：再把新数组的最后一个节点和旧数组中第一个节点对比
      - 如果相同，直接用新节点复用老节点
      - 更新完后，再将旧数组中的该节点移动到 与新节点相同的位置
   4. 不同：把新节点中第一个节点和旧数组中最后一个节点做对比
   5. 不同：查看旧数组中是否有新数组的第一个节点，没有就直接在新节点中插入
3. 递归处理

## 什么是虚拟 DOM？

所谓虚拟 DOM，就是用一个 JS 对象来描述一个 DOM 节点，像如下示例：

```js
<div class="a" id="b">我是内容</div>

{
  tag:'div',        // 元素标签
  attrs:{           // 属性
    class:'a',
    id:'b'
  },
  text:'我是内容',  // 文本内容
  children:[]       // 子元素
}
```

## 为什么要有虚拟 DOM？

Vue 是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作 DOM,而操作真实 DOM 又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的

一个简单的空 div 标签，就打印出这么多东西，更不用说复杂的、深嵌套的 DOM 节点了。由此可见，直接操作真实 DOM 是非常消耗性能的。

我们可以用 JS 的计算性能来换取操作 DOM 所消耗的性能。

既然我们逃不掉操作 DOM 这道坎,但是我们可以尽可能少的操作 DOM。那如何在更新视图的时候尽可能少的操作 DOM 呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作 DOM 了。这也就是上面所说的用 JS 的计算性能来换取操作 DOM 的性能。

我们可以用 JS 模拟出一个 DOM 节点，称之为虚拟 DOM 节点。当数据发生变化时，我们对比变化前后的虚拟 DOM 节点，通过 DOM-Diff 算法计算出需要更新的地方，然后去更新需要更新的视图。

这就是虚拟 DOM 产生的原因以及最大的用途。
# 原型和原型链

想了解原型需要从 JS 这门语言的设计初衷开始来理解

## 原型

### 一、从 js 设计目的开始

1994 年网景公司开发出了第一个网络浏览器，但是整个页面没有任何可以好访问者交互的能力

🆚 例如：表单提交，没有任何验证，什么都不输入然后提交表单后，就只能靠服务端返回信息提示，太消耗网络资源

然后就急需一门网页脚本语言，使得浏览器可以与网页互动

工程师 Brendan Eich 负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单

🚗 总结：设计js的目的就是让浏览器可以与网页互动

### 二、遇到的问题

- 要不要继承机制
- 如果不需要，那么如何将所有对象联系起来
- 如何共享属性和方法

#### 2.1 继承机制

1994 年正是面向对象编程最兴盛的时期，Brendan Eich 无疑受到了影响，**Javascript 里面所有的数据类型都是对象（object）**，这一点与 Java 非常相似。但是，他随即就遇到了一个难题

❓ 到底要不要设计**继承机制**呢 (O_o)??

- 如果真的是一种简易的脚本语言，其实不需要有"继承"机制
- 但是，Javascript 里面都是对象，必须有一种机制，将所有对象联系起来

但是，他不打算引入"类"（class）的概念，因为一旦有了"类"，Javascript 就是一种完整的面向对象编程语言了，违背了一开始的设计初衷

🚗 总结：不需要继承，但是需要一种机制将所有对象联系起来

#### 2.2 构造函数

他考虑到，C++和 Java 语言都使用 new 命令，生成实例。

C++的写法是：

```c++
　　ClassName *object = new ClassName(param);
```

Java 的写法是：

```java
　　Foo foo = new Foo();
```

因此，他就把 `new` 命令引入了 Javascript，用来从原型对象生成一个实例对象。

但是，Javascript 没有"类"，怎么来表示原型对象呢？

这时，他想到 C++和 Java 使用 new 命令时，都会调用"类"的构造函数（constructor）。他就做了一个简化的设计，在 Javascript 语言中，**new 命令后面跟的不是类，而是构造函数**。

```js
// 构造函数
function DOG(name) {
  this.name = name; //🚆 示例对象 this
}

// 对这个构造函数使用 new，就会生成一个狗对象的 实例。
const dogA = new DOG("大毛");
```

🚗 总结：使用构造函数来将所有的对象联系起来，**构造函数和普通函数的区别就是，构造函数前面有`new`**

#### 2.3 prototype
每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。

考虑到这一点，Brendan Eich 决定为构造函数设置一个`prototype`属性。

这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。

实例对象一旦创建，将自动引用 prototype 对象的属性和方法。

🚗 总结：为构造函数设置一个`prototype`属性，将需要共享的属性和方法放到里面
 
####  constructor
❓ 如何实现 继承呢？
任何一个prototype对象都有一个constructor属性，指向它的构造函数

每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性
```js
function Animal(){
　　this.species = "动物";
}
function Cat(name,color){
　　this.name = name;
　　this.color = color;
}
// ❓ 怎样才能使"Cat"继承"Animal"呢？

/*

*/


Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```
### 三、总结

由于所有的实例对象共享同一个 prototype 对象，那么从外界看起来，prototype 对象就好像是实例对象的原型，而实例对象则好像"继承"了 prototype 对象一样。

## 原型链

# 每个过程的优化

主要可以从几个方面来看：

- 网络连接
- 请求优化
- 响应优化
- 浏览器渲染

通过 `performance.timing` API 可以获取各个阶段的执行时间

## 一、 网络连接优化

主要针对的是 `重定向`、`DNS`、`TCP` 连接进行优化

- 避免重定向
- `DNS` 查找优化：页面采用预解析 `dns-prefach`，同时将同一资源放到一起，减少 domain 数量也是可以减少 DNS 查找
- 使用 `CND`（内容分发网路）
- HTTP1.1 版本，可以使用`keep-alive`和服务器建立长连接，让多个资源经过一个 `TCP` 链接传输

## 二、 请求方面优化

核心是减少浏览器向服务器发送的请求`数目`，以及请求资源的`大小`

#### 2.1 合理使用文件的压缩与合并

- 运用浏览器对资源**并行加载**的特性，在资源加载的`数量和大小`之间做一个合理的平衡
- 在**移动页面**中，将首屏的加载资源数量控制在 5 个之内，每个资源在`gzip`之后大小控制在 28.5kb 左右

#### 2.2 压缩图片

使用雪碧图，资源小的使用 base64 内联

#### 2.3 组件延迟加载

例如`vue`：

1. v-if 默认为 false 情况下不会加载组件，只有变为 true 的情况下才会进行加载，而且我们的组件加载后不需要销毁
2. 子组件可以通过插槽对父组件引用子组件包裹的内容进行分发。

```js
<template>
  <span>
    <slot v-if="initSuccess"></slot>
  </span>
</template>

<script>
  export default {
    name: "pl-lazy",
    props: {
      time: {
        required: false,
        default: 0
      }
    },
    data() {
      return {
        initSuccess: false
      }
    },
    created() {
      this.initSlot();
    },

    methods: {
      initSlot() {
        let vm = this;
        setTimeout(function () {
          vm.initSuccess = true;
        }, (Number(vm.time || 0)));
      }
    }
  }
</script>
// 注册
// 注册全局组件
import plLazy from "./components/common/components/plLazy";
Vue.component('pl-lazy', plLazy);

// 使用
<pl-lazy time="200">
这里放的是延迟加载的组件/dom内容
</pl-lazy>
```

#### 2.4 给 `Cookie` 瘦身

静态资源使用`CDN`等方式 放在和当前域 不同 的域上，以避免请求静态资源的时候携带 Cookie

#### 2.5 利用`CDN`提升浏览器资源的加载能力

#### 2.6 合理利用缓存策略

- 利用 manifest + 本地存储做持久化缓存
- 对访问 实时性不高 的资源 放到`IndexDB`或`WebSQL`中
- 使用 localForage 操作持久化缓存
- 库文件放入 `CDN` 或者开启强缓

## 三、 响应优化

- 优化服务端处理流程，如：使用缓存、优化数据库查询、减少查询次数
- 优化响应资源大小，如：开启 Gzip

## 页面加载的核心指标

- `TTFB` 首个字节
- `FP` 首次绘制，只有 div 根节点 ，对应 vue 中的 created
- `FCP` 首次有内容的绘制，页面的基本框架，但是没有数据内容，对应 monted
- `FMP` 首次有意义的绘制，包含所有元素和数据内容，对应 updated
- `TTI` 首次能交互时间
- `Long Task` 大于 等于 50ms 的任务
- `SSR & CSR`
- 同构化

## 四、 浏览器首屏渲染优化

### 首屏时间

用户打开网站开始，到浏览器首屏内容渲染完成的时间，

> 通常一个网站首屏时间在 5m 以内是比较优秀的，10m 是可以接受的，10m 以上 就比较差劲了

### 首屏优化方案

- 页面直出：骨架屏或 SSR
- 首帧渲染优化
- 资源动态加载
- 浏览器缓存
- 优化 js 执行时间
- 减少重排重绘
- 硬件加速

性能优化是前端开发一个非常重要的组成部分，如何更好地进行网络传输，如何优化浏览器渲染过程，来定位项目中存在的问题。Chrome DevTools 给我们提供了 2 种常用方式 Audits 和 Performance，Audits 可以对页面进行性能评分，同时，还会给我们提供一些优化建议。而 Performance 提供了非常多的运行时数据，能让我们看到更多细节数据。下面主要介绍一下如何使用 DevTools 中的 Performance 来进行性能分析

这里最主要是整体的界面渲染的时候，每个时间段执行的事件顺序，通过上图我们就能知道我们每个时间段（精确到毫秒）都做了什么，当鼠标放上去的时候，我们还可以大图的形式去查看我们每个时间段界面的渲染情况，Performance 就会将几个关键指标，诸如页面帧速 (FPS)、CPU 资源消耗、网络请求流量、V8 内存使用量 (堆内存) 等，按照时间顺序做成图表的形式展现出来。

## 第二部分：性能面板

<p>性能面板主要包括以下几部分  <br>1.Network 这里我们可以直观的看到资源加载的顺序与时长  <br>2.Interactions 用来记录用户交互操作，比如点击鼠标、输入文字、动画等  <br>3.Timings 用来记录一些关键的时间节点在何时产生的数据信息，诸如 FP、FCP、LCP 等  <br>4.Main 是Performance工具中比较重要的部分，记录了渲染进程中主线程的执行记录，点击main可以看到某个任务执行的具体情况  <br>5.Compositor 合成线程的执行记录，用来记录html绘制阶段 (Paint)结束后的图层合成操作  <br>6.Raster 光栅化线程池，用来让 GPU 执行光栅化的任务  <br>7.GPU GPU进程主线程的执行过程记录，如 可以直观看到何时启动GPU加速…  <br>Memory 选项，在勾选后，就会显示该折线图，通过该图可以看出我们在不同的时间段的执行情况。我们可以看到页面中的内存使用的情况，比如 JS Heap(堆)，如果曲线一直在增长，则说明存在内存泄露，如果相当长的一段时间，内存曲线都是没有下降的，这里是有发生内存泄露的可能的。  <br>通过对性能面板各个部分的分析与问题定位，可以更深刻的理解浏览器是如何工作的</p>

## 第三部分：Summary（性能摘要）

<p>它是一个用来统计在我们检测性能的时间范围内，都做了哪些事情： 
 <br>Loading ：加载时间  
 <br>Scripting ：js计算时间  
 <br>Rendering ：渲染时间  
 <br>Painting ：绘制时间  
 <br>Other ：其他时间  
 <br>Idle ：浏览器闲置时间
</p>

[参考](https://segmentfault.com/a/1190000023272526)

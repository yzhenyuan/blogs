(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{558:function(v,_,t){"use strict";t.r(_);var s=t(2),e=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[v._v("#")]),v._v(" HTTPS")]),v._v(" "),t("p",[v._v("http的问题：HTTP "),t("strong",[v._v("报文")]),v._v("传输过程中是"),t("strong",[v._v("明文")]),v._v("的，可以通过抓包的方式查看到，所以有安全问题，容易被"),t("strong",[v._v("劫持篡改")])]),v._v(" "),t("p",[v._v("为了解决这个问题，就有了 "),t("strong",[v._v("TLS")]),v._v(" ，"),t("code",[v._v("https")]),v._v(" = "),t("code",[v._v("http")]),v._v(" + "),t("code",[v._v("TLS")])]),v._v(" "),t("h2",{attrs:{id:"tls"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tls"}},[v._v("#")]),v._v(" TLS")]),v._v(" "),t("p",[v._v("TLS：安全传输层协议，用于在两个通信应用程序之间提供"),t("strong",[v._v("保密性和数据完整性")])]),v._v(" "),t("p",[v._v("该协议由两层组成：")]),v._v(" "),t("ol",[t("li",[v._v("TLS 记录协议（TLS Record）")]),v._v(" "),t("li",[v._v("TLS 握手协议（TLS Handshake）")])]),v._v(" "),t("p",[v._v("TLS 利用"),t("strong",[v._v("非对称加密演算")]),v._v("来对通信方做身份认证，之后交换"),t("strong",[v._v("对称密钥")]),v._v("作为会谈密钥（Session key）")]),v._v(" "),t("p",[v._v("https 分为两个"),t("strong",[v._v("阶段")]),v._v("：")]),v._v(" "),t("ol",[t("li",[v._v("通过"),t("strong",[v._v("非对称加解密")]),v._v("确认对方身份是否合法，若合法生成"),t("strong",[v._v("会话密钥")]),v._v("。（这一步是核心）")]),v._v(" "),t("li",[v._v("报文的在发送前，先用"),t("strong",[v._v("会话密钥")]),v._v("进行对称加密，在传输。")])]),v._v(" "),t("blockquote",[t("p",[v._v("非对称加密算法需要两个密钥：公开密钥（public key:简称公钥）和私有密钥（private key:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。因为加密和解密使用的是两个不同的密钥")])]),v._v(" "),t("h3",{attrs:{id:"tls-记录协议-tls-record"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tls-记录协议-tls-record"}},[v._v("#")]),v._v(" TLS 记录协议（TLS Record）")]),v._v(" "),t("h3",{attrs:{id:"tls-握手协议-tls-handshake"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tls-握手协议-tls-handshake"}},[v._v("#")]),v._v(" TLS 握手协议（TLS Handshake）")]),v._v(" "),t("p",[v._v("步骤：")]),v._v(" "),t("ol",[t("li",[v._v("客户端请求建立TLS链接，服务端向客户端发送一个随机数"),t("code",[v._v("random A")]),v._v("和 "),t("strong",[v._v("CA证书")])]),v._v(" "),t("li",[v._v("客户端对证书验证，通过后生成一个随机数 "),t("code",[v._v("random B")]),v._v("，用公钥对 "),t("code",[v._v("B")]),v._v(" 加密，同时用 "),t("code",[v._v("B")]),v._v("生成一段签名发送给服务端")]),v._v(" "),t("li",[v._v("服务端用私钥解密，用解密后的 key 生成签名，并与客户端传来的签名进行比较，通过后生成一个随机数"),t("code",[v._v("random C")]),v._v("，并用私钥加密，还有随机数生成的"),t("code",[v._v("hash 值")]),v._v("，一并发给客户端")]),v._v(" "),t("li",[v._v("客户端用公钥解密，并校验 hash 值通过后，两端利用 "),t("code",[v._v("A")]),v._v(" "),t("code",[v._v("B")]),v._v(" "),t("code",[v._v("C")]),v._v(" 通过一定的算法生成 session key，后续的报文将通过 session key 对称加密进行传输。")])]),v._v(" "),t("h3",{attrs:{id:"ca-证书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ca-证书"}},[v._v("#")]),v._v(" CA 证书")]),v._v(" "),t("p",[v._v("假如没有证书验证这一环节，那么公钥在传输过程极有可能被中间人拦截，将服务端的公钥换成它自己的公钥，返回给客户端，这样就起不到加密的作用了，这就是"),t("strong",[v._v("中间人攻击")])]),v._v(" "),t("p",[t("strong",[v._v("CA证书")]),v._v("，是由 CA 机构颁发的一个凭证，里面关键的信息有，签名算法、签名hash算法、颁发者、有效期、公钥、指纹，这个两个算法就表示对称阶段和非对称阶段采用的算法，公钥就是服务端的公钥，在申请的时候，企业需要上传公钥给CA机构，重点是这个指纹，这个指纹是由 CA 机构通过私钥对一段签名加密生成的。")])])}),[],!1,null,null,null);_.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{526:function(e,t,s){"use strict";s.r(t);var n=s(2),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"reflect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reflect"}},[e._v("#")]),e._v(" Reflect")]),e._v(" "),s("p",[e._v("Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到"),s("code",[e._v("Reflect")]),e._v("对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。")])]),e._v(" "),s("li",[s("p",[e._v("修改某些Object方法的返回结果，让其变得更合理。比如，"),s("code",[e._v("Object.defineProperty(obj, name, desc)")]),e._v("在无法定义属性时，会抛出一个错误，而"),s("code",[e._v("Reflect.defineProperty(obj, name, desc)")]),e._v("则会返回false。")])]),e._v(" "),s("li",[s("p",[e._v("让Object操作都变成函数行为。某些Object操作是命令式，比如"),s("code",[e._v("name in obj和delete obj[name]")]),e._v("，而"),s("code",[e._v("Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)")]),e._v("让它们变成了函数行为。")])])]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 老写法")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'assign'")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("in")]),e._v(" Object "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// true")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 新写法")]),e._v("\nReflect"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("has")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'assign'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// true")]),e._v("\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("ol",{attrs:{start:"4"}},[s("li",[e._v("Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{499:function(v,a,t){v.exports=t.p+"assets/img/v8.870bf509.png"},500:function(v,a,t){v.exports=t.p+"assets/img/v8-js.f531d07f.jpeg"},550:function(v,a,t){"use strict";t.r(a);var _=t(2),r=Object(_.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"v8-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎"}},[v._v("#")]),v._v(" V8 引擎")]),v._v(" "),_("p",[v._v("V8 是由 Google 开发的开源 JavaScript 引擎，也被称为虚拟机，模拟实际计算机各种功能来实现代码的编译和执行。\n"),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/28590489",target:"_blank",rel:"noopener noreferrer"}},[v._v("理解 V8 的字节码"),_("OutboundLink")],1)]),v._v(" "),_("ul",[_("li",[v._v("V8 的执行机制")]),v._v(" "),_("li",[v._v("闭包给 Chrome V8 带来的问题及其解决策略")]),v._v(" "),_("li",[v._v("堆空间和栈空间")]),v._v(" "),_("li",[v._v("机器码、字节码")]),v._v(" "),_("li",[v._v("隐藏类和内联缓存")]),v._v(" "),_("li",[v._v("异步编程与消息队列")]),v._v(" "),_("li",[v._v("垃圾回收")])]),v._v(" "),_("h2",{attrs:{id:"为什么需要-javascript-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要-javascript-引擎"}},[v._v("#")]),v._v(" 为什么需要 JavaScript 引擎")]),v._v(" "),_("p",[v._v("我们写的 JavaScript 代码直接交给浏览器或者 Node 执行时，底层的 CPU 是不认识的，也没法执行。CPU 只认识自己的指令集，指令集对应的是汇编代码。写汇编代码是一件很痛苦的事情。并且不同类型的 CPU 的指令集是不一样的，那就意味着需要给每一种 CPU 重写汇编代码。")]),v._v(" "),_("p",[v._v("JavaScirpt 引擎可以将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等)对应的汇编代码，这样我们就不需要去翻阅每个 CPU 的指令集手册来编写汇编代码了。当然，JavaScript 引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收。")]),v._v(" "),_("h4",{attrs:{id:"热门-javascript-引擎"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#热门-javascript-引擎"}},[v._v("#")]),v._v(" 热门 JavaScript 引擎")]),v._v(" "),_("ul",[_("li",[v._v("V8 (Google)，用 C++编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。")]),v._v(" "),_("li",[v._v("JavaScriptCore (Apple)，开放源代码，用于 webkit 型浏览器，如 Safari ，2008 年实现了编译器和字节码解释器，升级为了 SquirrelFish。苹果内部代号为“Nitro”的 JavaScript 引擎也是基于 JavaScriptCore 引擎的。")]),v._v(" "),_("li",[v._v("Rhino，由 Mozilla 基金会管理，开放源代码，完全以 Java 编写，用于 HTMLUnit")]),v._v(" "),_("li",[v._v("SpiderMonkey (Mozilla)，第一款 JavaScript 引擎，早期用于 Netscape Navigator，现时用于 Mozilla Firefox。")]),v._v(" "),_("li",[v._v("Chakra (JScript 引擎)，用于 Internet Explorer。")]),v._v(" "),_("li",[v._v("Chakra (JavaScript 引擎)，用于 Microsoft Edge。")]),v._v(" "),_("li",[v._v("KJS，KDE 的 ECMAScript／JavaScript 引擎，最初由哈里·波顿开发，用于 KDE 项目的 Konqueror 网页浏览器中。")]),v._v(" "),_("li",[v._v("JerryScript — 三星推出的适用于嵌入式设备的小型 JavaScript 引擎。")]),v._v(" "),_("li",[v._v("其他：Nashorn、QuickJS 、 Hermes")])]),v._v(" "),_("h2",{attrs:{id:"v8-的执行机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-的执行机制"}},[v._v("#")]),v._v(" V8 的执行机制")]),v._v(" "),_("p",[v._v("Google V8 引擎是用 C ++编写的开源高性能 JavaScript 和 WebAssembly 引擎，它已被用于 Chrome 和 Node.js 等。可以运行在 Windows 7+，macOS 10.12+和使用 x64，IA-32，ARM 或 MIPS 处理器的 Linux 系统上。V8 最早被开发用以嵌入到 Google 的开源浏览器 Chrome 中，第一个版本随着第一版 Chrome 于 2008 年 9 月 2 日发布。但是 V8 是一个可以独立运行的模块，完全可以嵌入到任何 C ++应用程序中。著名的 Node.js( 一个异步的服务器框架，可以在服务端使用 JavaScript 写出高效的网络服务器 ) 就是基于 V8 引擎的，Couchbase, MongoDB 也使用了 V8 引擎。")]),v._v(" "),_("p",[v._v("和其他 JavaScript 引擎一样，V8 会编译 / 执行 JavaScript 代码，管理内存，负责垃圾回收，与宿主语言的交互等。通过暴露宿主对象 ( 变量，函数等 ) 到 JavaScript，JavaScript 可以访问宿主环境中的对象，并在脚本中完成对宿主对象的操作。")]),v._v(" "),_("h4",{attrs:{id:"v8-引擎的内部结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎的内部结构"}},[v._v("#")]),v._v(" V8 引擎的内部结构")]),v._v(" "),_("p",[v._v("V8 是一个非常复杂的项目，有超过 100 万行 C++代码。它由许多子模块构成，其中这 4 个模块是最重要的：")]),v._v(" "),_("ul",[_("li",[v._v("Parser：负责将 JavaScript 源码转换为 Abstract Syntax Tree (AST)")]),v._v(" "),_("li",[v._v("Ignition：interpreter，即解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；解释器执行时主要有四个模块，内存中的字节码、寄存器、栈、堆。")]),v._v(" "),_("li",[v._v("通常有两种类型的解释器，\n"),_("ul",[_("li",[v._v("基于栈 (Stack-based)和基于寄存器 (Register-based)，基于栈的解释器使用栈来保存函数参数、中间运算结果、变量等；基于寄存器的虚拟机则支持寄存器的指令操作，使用寄存器来保存参数、中间计算结果。通常，基于栈的虚拟机也定义了少量的寄存器，基于寄存器的虚拟机也有堆栈，其区别体现在它们提供的指令集体系。大多数解释器都是基于栈的，比如 Java 虚拟机，.Net 虚拟机，还有早期的 V8 虚拟机。基于堆栈的虚拟机在处理函数调用、解决递归问题和切换上下文时简单明快。而现在的 V8 虚拟机则采用了基于寄存器的设计，它将一些中间数据保存到寄存器中。")])])]),v._v(" "),_("li",[v._v("TurboFan：compiler，即编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化的汇编代码；")]),v._v(" "),_("li",[v._v("Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收。")])]),v._v(" "),_("blockquote",[_("p",[v._v("简单地说，Parser 将 JS 源码转换为 AST，→ Ignition 将 AST 转换为 Bytecode，→ 最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。")])]),v._v(" "),_("p",[v._v("Parser，Ignition 以及 TurboFan 可以将 JS 源码编译为汇编代码，其流程图如下：\n"),_("img",{attrs:{src:t(499),alt:"Parser，Ignition 以及 TurboFan 可以将 JS 源码编译为汇编代码，其流程图如下："}})]),v._v(" "),_("ul",[_("li",[v._v("如果函数没有被调用，则 V8 不会去编译它。")]),v._v(" "),_("li",[v._v("如果函数只被调用 1 次，则 Ignition 将其编译 Bytecode 就直接解释执行了。TurboFan 不会进行优化编译，因为它需要 Ignition 收集函数执行时的类型信息。这就要求函数至少需要执行 1 次，TurboFan 才有可能进行优化编译。")]),v._v(" "),_("li",[v._v("如果函数被调用多次，则它有可能会被识别为热点函数，且 Ignition 收集的类型信息证明可以进行优化编译的话，这时 TurboFan 则会将 Bytecode 编译为 Optimized Machine Code（已优化的机器码），以提高代码的执行性能。")])]),v._v(" "),_("p",[v._v("在运行 C、C++以及 Java 等程序之前，需要进行编译，不能直接执行源码；但对于 JavaScript 来说，我们可以直接执行源码(比如：node test.js)，它是在运行的时候先编译再执行，这种方式被称为即时编译(Just-in-time compilation)，简称为 JIT。因此，V8 也属于 JIT 编译器。")]),v._v(" "),_("h4",{attrs:{id:"v8-是怎么执行一段-javascript-代码的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-是怎么执行一段-javascript-代码的"}},[v._v("#")]),v._v(" V8 是怎么执行一段 JavaScript 代码的")]),v._v(" "),_("p",[v._v("在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计（混合使用编译器和解释器的技术），这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。V8 出现之后，各大厂商也都在自己的 JavaScript 虚拟机中引入了 JIT 机制，所以目前市面上 JavaScript 虚拟机都有着类似的架构。另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存、隐藏类等机制，进一步优化了 JavaScript 代码的编译执行效率。")]),v._v(" "),_("p",[v._v("V8 执行一段 JavaScript 的流程图：\n"),_("img",{attrs:{src:t(500),alt:"V8 执行一段 JavaScript 的流程图"}})]),v._v(" "),_("p",[v._v("V8 本质上是一个虚拟机，因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段：")]),v._v(" "),_("ol",[_("li",[v._v("第一种是将高级代码转换为二进制代码，再让计算机去执行；")]),v._v(" "),_("li",[v._v("另外一种方式是在计算机安装一个解释器，并由解释器来解释执行。")])]),v._v(" "),_("p",[v._v("解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺点，V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。")]),v._v(" "),_("ul",[_("li",[v._v("总结：\nV8 执行一段 JavaScript 代码所经历的主要流程包括：\n"),_("ul",[_("li",[v._v("初始化基础环境；")]),v._v(" "),_("li",[v._v("解析源码生成 AST 和作用域；")]),v._v(" "),_("li",[v._v("依据 AST 和作用域生成字节码；")]),v._v(" "),_("li",[v._v("解释执行字节码；")]),v._v(" "),_("li",[v._v("监听热点代码；")]),v._v(" "),_("li",[v._v("优化热点代码为二进制的机器代码；")]),v._v(" "),_("li",[v._v("反优化生成的二进制机器代码。")])])])]),v._v(" "),_("h2",{attrs:{id:"闭包给-chrome-v8-带来的问题及其解决策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#闭包给-chrome-v8-带来的问题及其解决策略"}},[v._v("#")]),v._v(" 闭包给 Chrome V8 带来的问题及其解决策略")]),v._v(" "),_("h4",{attrs:{id:"惰性解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#惰性解析"}},[v._v("#")]),v._v(" 惰性解析")]),v._v(" "),_("p",[v._v("所谓惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。")]),v._v(" "),_("ul",[_("li",[v._v("在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：\n"),_("ul",[_("li",[v._v("首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；")]),v._v(" "),_("li",[v._v("其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存。")])])]),v._v(" "),_("li",[v._v("基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。")]),v._v(" "),_("li",[v._v("闭包给惰性解析带来的问题：上文的 d 不能随着 foo 函数的执行上下文被销毁掉。")])]),v._v(" "),_("h4",{attrs:{id:"预解析器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#预解析器"}},[v._v("#")]),v._v(" 预解析器")]),v._v(" "),_("p",[v._v("V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析")]),v._v(" "),_("ul",[_("li",[v._v("判断当前函数是不是存在一些语法上的错误，发现了语法错误，那么就会向 V8 抛出语法错误；")]),v._v(" "),_("li",[v._v("检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。")])]),v._v(" "),_("h4",{attrs:{id:"v8-内部是如何存储对象的-快属性和慢属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-内部是如何存储对象的-快属性和慢属性"}},[v._v("#")]),v._v(" V8 内部是如何存储对象的：快属性和慢属性")]),v._v(" "),_("p",[v._v("因为 JavaScript 中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。为了提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性 element 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性。properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。")]),v._v(" "),_("p",[v._v("通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率，V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。")]),v._v(" "),_("p",[v._v("但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。")]),v._v(" "),_("h2",{attrs:{id:"堆空间和栈空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆空间和栈空间"}},[v._v("#")]),v._v(" 堆空间和栈空间")]),v._v(" "),_("h4",{attrs:{id:"栈空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#栈空间"}},[v._v("#")]),v._v(" 栈空间")]),v._v(" "),_("p",[v._v("现代语言都是基于函数的，每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁，因此，我们会使用栈这种数据结构来管理函数的调用过程，我们也把管理函数调用过程的栈结构称之为调用栈。")]),v._v(" "),_("p",[v._v("栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。")]),v._v(" "),_("p",[v._v("栈空间的最大的特点是"),_("code",[v._v("空间连续")]),v._v("，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，"),_("strong",[v._v("V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。")])]),v._v(" "),_("ul",[_("li",[v._v("栈的优势和缺点：\n"),_("ul",[_("li",[v._v("栈的结构非常适合函数调用过程。")]),v._v(" "),_("li",[v._v("在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。")]),v._v(" "),_("li",[v._v("虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的")])])])]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("  // 栈溢出\nfunction factorial(n) {\n  if (n === 1) {\n    return 1;\n  }\n  return n * factorial(n - 1);\n}\nconsole.log(factorial(50000));\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br")])]),_("h4",{attrs:{id:"堆空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#堆空间"}},[v._v("#")]),v._v(" 堆空间")]),v._v(" "),_("p",[_("code",[v._v("堆空间是一种树形的存储结构")]),v._v("，用来存储对象类型的离散的数据，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。")]),v._v(" "),_("p",[v._v("宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。")]),v._v(" "),_("h4",{attrs:{id:"继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[v._v("#")]),v._v(" 继承")]),v._v(" "),_("p",[v._v("继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。")]),v._v(" "),_("p",[v._v("JavaScript 的每个对象都包含了一个隐藏属性 "),_("strong",[v._v("proto")]),v._v(" ，我们就把该隐藏属性 "),_("strong",[v._v("proto")]),v._v(" 称之为该对象的原型 (prototype)，"),_("strong",[v._v("proto")]),v._v(" 指向了内存中的另外一个对象，我们就把 "),_("strong",[v._v("proto")]),v._v(" 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。")]),v._v(" "),_("p",[v._v("JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。")]),v._v(" "),_("h4",{attrs:{id:"隐藏属性proto"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐藏属性proto"}},[v._v("#")]),v._v(" 隐藏属性"),_("strong",[v._v("proto")])]),v._v(" "),_("p",[v._v("通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 "),_("strong",[v._v("proto")]),v._v("，但是在实际项目中，我们不应该直接通过 "),_("strong",[v._v("proto")]),v._v(" 来访问或者修改该属性，其主要原因有两个：")]),v._v(" "),_("ul",[_("li",[v._v("首先，这是隐藏属性，并不是标准定义的;")]),v._v(" "),_("li",[v._v("其次，使用该属性会造成严重的性能问题。因为 JavaScript 通过隐藏类优化了很多原有的对象结构，所以通过直接修改"),_("strong",[v._v("proto")]),v._v("会直接破坏现有已经优化的结构，触发 V8 重构该对象的隐藏类！")])]),v._v(" "),_("h5",{attrs:{id:"构造函数是怎么创建对象的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造函数是怎么创建对象的"}},[v._v("#")]),v._v(" 构造函数是怎么创建对象的？")]),v._v(" "),_("p",[v._v("在 JavaScript 中，使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦。其实是 JavaScript 为了吸引 Java 程序员、在语法层面去蹭 Java 热点，所以就被硬生生地强制加入了非常不协调的关键字 new。")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("function DogFactory(type, color) {\n  this.type = type;\n  this.color = color;\n}\nvar dog = new DogFactory('Dog', 'Black');\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br")])]),_("p",[v._v("其实当 V8 执行上面这段代码时，V8 在背后悄悄地做了以下几件事情：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("var dog = {};\ndog.__proto__ = DogFactory.prototype;\nDogFactory.call(dog, 'Dog', 'Black');\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("h2",{attrs:{id:"机器码、字节码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#机器码、字节码"}},[v._v("#")]),v._v(" 机器码、字节码")]),v._v(" "),_("h4",{attrs:{id:"v8-为什么要引入字节码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-为什么要引入字节码"}},[v._v("#")]),v._v(" V8 为什么要引入字节码")]),v._v(" "),_("p",[v._v("早期的 V8 为了提升代码的执行速度，直接将 JavaScript 源代码编译成了没有优化的二进制机器代码，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为热点代码，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。")]),v._v(" "),_("p",[v._v("随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两个致命的问题：")]),v._v(" "),_("ul",[_("li",[v._v("时间问题：编译时间过久，影响代码启动速度；")]),v._v(" "),_("li",[v._v("空间问题：缓存编译后的二进制代码占用更多的内存。")])]),v._v(" "),_("p",[v._v("这两个问题无疑会阻碍 V8 在移动设备上的普及，于是 V8 团队大规模重构代码，引入了中间的字节码。字节码的优势有如下三点：")]),v._v(" "),_("ul",[_("li",[v._v("解决启动问题：生成字节码的时间很短；")]),v._v(" "),_("li",[v._v("解决空间问题：字节码虽然占用的空间比原始的 JavaScript 多，但是相较于机器代码，字节码还是小了太多，缓存字节码会大大降低内存的使用。")]),v._v(" "),_("li",[v._v("代码架构清晰：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。")])]),v._v(" "),_("p",[v._v("Bytecode 某种程度上就是汇编语言，只是它没有对应特定的 CPU，或者说它对应的是虚拟的 CPU。这样的话，生成 Bytecode 时简单很多，无需为不同的 CPU 生产不同的代码。要知道，V8 支持 9 种不同的 CPU，引入一个中间层 Bytecode，可以简化 V8 的编译流程，提高可扩展性。")]),v._v(" "),_("p",[v._v("如果我们在不同硬件上去生成 Bytecode，会发现生成代码的指令是一样的。")]),v._v(" "),_("h2",{attrs:{id:"隐藏类和内联缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐藏类和内联缓存"}},[v._v("#")]),v._v(" 隐藏类和内联缓存")]),v._v(" "),_("p",[v._v("JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。")]),v._v(" "),_("h4",{attrs:{id:"为什么静态语言的效率更高"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么静态语言的效率更高"}},[v._v("#")]),v._v(" 为什么静态语言的效率更高?")]),v._v(" "),_("p",[v._v("静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。")]),v._v(" "),_("p",[v._v("JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。")]),v._v(" "),_("h4",{attrs:{id:"将静态的特性引入到-v8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#将静态的特性引入到-v8"}},[v._v("#")]),v._v(" 将静态的特性引入到 V8")]),v._v(" "),_("p",[v._v("V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。")]),v._v(" "),_("p",[v._v("具体地讲，V8 对每个对象做如下两点假设：")]),v._v(" "),_("ol",[_("li",[v._v("对象创建好了之后就不会添加新的属性；")]),v._v(" "),_("li",[v._v("对象创建好了之后也不会删除属性。")])]),v._v(" "),_("p",[v._v("符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：")]),v._v(" "),_("ol",[_("li",[v._v("对象中所包含的所有的属性；")]),v._v(" "),_("li",[v._v("每个属性相对于对象的偏移量。")])]),v._v(" "),_("p",[v._v("有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。")]),v._v(" "),_("p",[_("strong",[v._v("在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类")])]),v._v(" "),_("p",[v._v("map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。")]),v._v(" "),_("h4",{attrs:{id:"多个对象共用一个隐藏类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多个对象共用一个隐藏类"}},[v._v("#")]),v._v(" 多个对象共用一个隐藏类")]),v._v(" "),_("p",[v._v("在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：")]),v._v(" "),_("ul",[_("li",[v._v("减少隐藏类的创建次数，也间接加速了代码的执行速度；")]),v._v(" "),_("li",[v._v("减少了隐藏类的存储空间。\n那么，什么情况下两个对象的形状是相同的，要满足以下两点：")]),v._v(" "),_("li",[v._v("相同的属性名称；")]),v._v(" "),_("li",[v._v("相等的属性个数。")])]),v._v(" "),_("h4",{attrs:{id:"重新构建隐藏类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重新构建隐藏类"}},[v._v("#")]),v._v(" 重新构建隐藏类")]),v._v(" "),_("ul",[_("li",[v._v("给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。")]),v._v(" "),_("li",[v._v("每次给对象添加了一个新属性之后，该对象的隐藏类的地址都会改变，这也就意味着隐藏类也随着改变了；如果删除对象的某个属性，那么对象的形状也就随着发生了改变，这时 V8 也会重建该对象的隐藏类；")]),v._v(" "),_("li",[v._v("最佳实践\n"),_("ul",[_("li",[v._v("使用字面量初始化对象时，要保证属性的顺序是一致的；")]),v._v(" "),_("li",[v._v("尽量使用字面量一次性初始化完整对象属性；")]),v._v(" "),_("li",[v._v("尽量避免使用 delete 方法。")])])])]),v._v(" "),_("h4",{attrs:{id:"通过内联缓存来提升函数执行效率"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过内联缓存来提升函数执行效率"}},[v._v("#")]),v._v(" 通过内联缓存来提升函数执行效率")]),v._v(" "),_("p",[v._v("虽然隐藏类能够加速查找对象的速度，但是在 V8 查找对象属性值的过程中，依然有查找对象的隐藏类和根据隐藏类来查找对象属性值的过程。如果一个函数中利用了对象的属性，并且这个函数会被多次执行：")]),v._v(" "),_("h4",{attrs:{id:"通常-v8-获取-obj-x-的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通常-v8-获取-obj-x-的流程"}},[v._v("#")]),v._v(" 通常 V8 获取 obj.x 的流程")]),v._v(" "),_("ul",[_("li",[v._v("找对象 obj 的隐藏类；")]),v._v(" "),_("li",[v._v("再通过隐藏类查找 x 属性偏移量；")]),v._v(" "),_("li",[v._v("然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 obj.x 的流程也需要反复被执行；")])]),v._v(" "),_("h4",{attrs:{id:"内联缓存及其原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内联缓存及其原理"}},[v._v("#")]),v._v(" 内联缓存及其原理")]),v._v(" "),_("ul",[_("li",[v._v("函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC；")]),v._v(" "),_("li",[v._v("IC 的原理：在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。")]),v._v(" "),_("li",[v._v("IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。")]),v._v(" "),_("li",[v._v("反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。")]),v._v(" "),_("li",[v._v("当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return obj.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 obj.x 的属性值了。这样就大大提升了 V8 的执行效率。")])]),v._v(" "),_("h4",{attrs:{id:"单态、多态和超态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单态、多态和超态"}},[v._v("#")]),v._v(" 单态、多态和超态")]),v._v(" "),_("ul",[_("li",[v._v("如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；")]),v._v(" "),_("li",[v._v("如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (polymorphic)；")]),v._v(" "),_("li",[v._v("如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。")]),v._v(" "),_("li",[v._v("单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(obj) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 obj 对象。")])]),v._v(" "),_("h4",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("V8 引入了内联缓存（IC），IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。但是针对函数中的同一段代码，如果对象的隐藏类是不同的，那么反馈向量也会记录这些不同的隐藏类，这就出现了多态和超态的情况。我们在实际项目中，要尽量避免出现多态或者超态的情况。")]),v._v(" "),_("h2",{attrs:{id:"异步编程与消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异步编程与消息队列"}},[v._v("#")]),v._v(" 异步编程与消息队列")]),v._v(" "),_("h4",{attrs:{id:"v8-是如何执行回调函数的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8-是如何执行回调函数的"}},[v._v("#")]),v._v(" V8 是如何执行回调函数的")]),v._v(" "),_("p",[v._v("回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。")]),v._v(" "),_("p",[v._v("UI 线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest：")]),v._v(" "),_("ul",[_("li",[v._v("setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。")]),v._v(" "),_("li",[v._v("XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。")])]),v._v(" "),_("h4",{attrs:{id:"宏任务和微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[v._v("#")]),v._v(" 宏任务和微任务")]),v._v(" "),_("p",[v._v("调用栈：调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。主线程在执行任务的过程中，如果函数的调用层次过深，可能造成栈溢出的错误，我们可以使用 setTimeout 来解决栈溢出的问题。setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将回调函数封装成宏任务，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个宏任务。")]),v._v(" "),_("p",[v._v("宏任务：就是指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。")]),v._v(" "),_("p",[v._v("微任务：你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。")]),v._v(" "),_("p",[v._v("JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。")]),v._v(" "),_("p",[v._v("微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。")]),v._v(" "),_("h4",{attrs:{id:"微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[v._v("#")]),v._v(" 微任务：")]),v._v(" "),_("ul",[_("li",[v._v("如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以*执行微任务时，不会导致栈的无限扩张；")]),v._v(" "),_("li",[v._v("和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。因此在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。")]),v._v(" "),_("li",[v._v("微任务依然是在当前的任务中执行的，所以如果在微任务中循环触发新的微任务，那么将导致消息队列中的其他任务没有机会被执行。")])]),v._v(" "),_("h4",{attrs:{id:"前端异步编程方案史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端异步编程方案史"}},[v._v("#")]),v._v(" 前端异步编程方案史")]),v._v(" "),_("ul",[_("li",[v._v("Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的回调地狱问题。")]),v._v(" "),_("li",[v._v("Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。")]),v._v(" "),_("li",[v._v("但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程。我们想要通过线性的方式来编写异步代码，要实现这个理想，最关键的是要能实现函数暂停和恢复执行的功能。而生成器就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)。")]),v._v(" "),_("li",[v._v("但是在生成器之外，我们还需要一个触发器来驱动生成器的执行。前端的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程。")])]),v._v(" "),_("p",[v._v("协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。")]),v._v(" "),_("p",[v._v("正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。每一时刻，该线程只能执行其中某一个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。")]),v._v(" "),_("h2",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),_("h4",{attrs:{id:"垃圾数据"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾数据"}},[v._v("#")]),v._v(" 垃圾数据")]),v._v(" "),_("p",[v._v("从“GC Roots”对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。")]),v._v(" "),_("h4",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),_("p",[v._v("垃圾回收大致可以分为以下几个步骤：")]),v._v(" "),_("ol",[_("li",[v._v("第一步，通过 GC Root 标记空间中活动对象和非活动对象。目前 V8 采用的可访问性（reachability）算法来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：\n"),_("ul",[_("li",[v._v("全局的 window 对象（位于每个 iframe 中）；")]),v._v(" "),_("li",[v._v("文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成；")]),v._v(" "),_("li",[v._v("存放栈上变量。")]),v._v(" "),_("li",[v._v("通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象；")]),v._v(" "),_("li",[v._v("通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。")]),v._v(" "),_("li",[v._v("在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：")])])]),v._v(" "),_("li",[v._v("第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。")]),v._v(" "),_("li",[v._v("第三步，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片(比如副垃圾回收器)。")])]),v._v(" "),_("h4",{attrs:{id:"垃圾回收-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收-2"}},[v._v("#")]),v._v(" 垃圾回收")]),v._v(" "),_("p",[v._v("V8 依据代际假说，将堆内存划分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。代际假说有两个特点：")]),v._v(" "),_("ul",[_("li",[v._v("第一个是大部分对象都是“朝生夕死”的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问；")]),v._v(" "),_("li",[v._v("第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。")])]),v._v(" "),_("p",[v._v("为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。")]),v._v(" "),_("ul",[_("li",[v._v("主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。")]),v._v(" "),_("li",[v._v("老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。")]),v._v(" "),_("li",[v._v("这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。")]),v._v(" "),_("li",[v._v("副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。")]),v._v(" "),_("li",[v._v("副垃圾回收器还会采用对象晋升策略，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。")]),v._v(" "),_("li",[v._v("主垃圾回收器负责收集老生代中的垃圾数据，副垃圾回收器负责收集新生代中的垃圾数据。")]),v._v(" "),_("li",[v._v("副垃圾回收器采用了 Scavenge 算法，是把新生代空间对半划分为两个区域（有些地方也称作 From 和 To 空间），一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。")]),v._v(" "),_("li",[v._v("主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://mp.weixin.qq.com/s/0OxNG1AWrkTIVK6N36wk4A",target:"_blank",rel:"noopener noreferrer"}},[v._v("参考：Chrome V8"),_("OutboundLink")],1)]),v._v(" "),_("h2",{attrs:{id:"v8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v8"}},[v._v("#")]),v._v(" v8")]),v._v(" "),_("p",[v._v("js在执行的时候都要经过V8")]),v._v(" "),_("h3",{attrs:{id:"libuv"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#libuv"}},[v._v("#")]),v._v(" libuv")]),v._v(" "),_("p",[v._v("不属于v8，但是在node执行过程中辅助的一个环节")]),v._v(" "),_("ul",[_("li",[v._v("执行逻辑与顺序")]),v._v(" "),_("li",[v._v("内部深层原理")]),v._v(" "),_("li",[v._v("c的实现机制")]),v._v(" "),_("li",[v._v("DSL\\NLP\\AST")]),v._v(" "),_("li",[v._v("浏览器运行机制")])]),v._v(" "),_("p",[v._v("详细过程")]),v._v(" "),_("ol",[_("li",[v._v("node启动时，创建了一个类似while(true)的循环体（每次执行一次循环体就称为一次tick）")]),v._v(" "),_("li",[v._v("每个tick的过程就是查看是否有事件等待处理")]),v._v(" "),_("li",[v._v("如果有则取出事件及其相关的回调函数去执行，然后执行下一个tick")])]),v._v(" "),_("p",[v._v("执行逻辑")]),v._v(" "),_("ol",[_("li",[v._v("先询问"),_("strong",[v._v("事件观察者")]),v._v("是否有任务需要执行")]),v._v(" "),_("li")]),v._v(" "),_("p",[v._v("总结：")]),v._v(" "),_("ol",[_("li",[v._v("在执行的时候是一个 "),_("code",[v._v("while(true)")]),v._v(" 的循环体，")]),v._v(" "),_("li",[v._v("整个过程不需要等待回调函数执行完成，他会继续向下执行，直到观察者回答没有了，线程才结束")])]),v._v(" "),_("h3",{attrs:{id:"浏览器中的event-loop跟libuv的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的event-loop跟libuv的区别"}},[v._v("#")]),v._v(" 浏览器中的event loop跟libuv的区别")]),v._v(" "),_("p",[v._v("它主要有一个主线程和stack调用栈，所有任务都会等主线程去执行")])])}),[],!1,null,null,null);a.default=r.exports}}]);
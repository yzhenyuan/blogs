(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{568:function(e,t,a){"use strict";a.r(t);var v=a(2),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[e._v("#")]),e._v(" React Fiber")]),e._v(" "),a("h2",{attrs:{id:"为什么要了解-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要了解-fiber"}},[e._v("#")]),e._v(" 为什么要了解 Fiber")]),e._v(" "),a("p",[a("strong",[e._v("Fiber 是什么？")]),e._v("---计算机有进程（Process）和线程（Thread）的概念，然后，还有个"),a("code",[e._v("Fiber")]),e._v("概念，意思是比线程(Thread)控制得更精密的并发处理机制。")]),e._v(" "),a("p",[e._v("react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是"),a("strong",[e._v("同步")]),e._v("的。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，因为 JavaScript 是单线程的，任何交互、布局、渲染都会停止，使得 react 在动画、手势等应用中效果比较差")]),e._v(" "),a("h3",{attrs:{id:"那么如何解决呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#那么如何解决呢"}},[e._v("#")]),e._v(" 那么如何解决呢？")]),e._v(" "),a("ol",[a("li",[e._v("提升计算机的算力，但是我们的应用可能跑在千差万别的设备上，总会有很多设备硬件水平不是很高")]),e._v(" "),a("li",[a("code",[e._v("web worker")]),e._v("，让 diff 操作在另外一个线程中并行执行。这是个好思路，但是这可能会带来额外的开销，react 官方并没有采用这个策略")]),e._v(" "),a("li",[e._v("React Fiber：将 diff 操作变成可中断的，只有当浏览器空闲时再做 diff。避免 diff 更新长时间占据浏览器线程")])]),e._v(" "),a("p",[e._v("事实上，我们要解决的其实并不是性能问题，而是 "),a("strong",[e._v("调度问题")]),e._v("。用户的交互事件属于高优先级，需要尽快响应。而 diff 操作优先级相对没那么高，可以在几个时间段内分片执行。")]),e._v(" "),a("h2",{attrs:{id:"什么是-react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-react-fiber"}},[e._v("#")]),e._v(" 什么是 React Fiber")]),e._v(" "),a("p",[e._v("为了解决 diff 时间过长导致的卡顿问题，React Fiber 用类似 "),a("code",[e._v("requestIdleCallback")]),e._v(" 的机制来做异步 diff")]),e._v(" "),a("h3",{attrs:{id:"了解-requestidlecallback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#了解-requestidlecallback"}},[e._v("#")]),e._v(" 了解 requestIdleCallback")]),e._v(" "),a("p",[a("code",[e._v("requestIdleCallback")]),e._v(" 方法将在浏览器的空闲时段内调用函数。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。")]),e._v(" "),a("p",[e._v("什么是空闲时段？当浏览器呈现一帧所需的时间少于屏幕刷新率时间(对于 60Hz 的设备，帧间隔应小于 16ms)，他们两之差就是空闲时间")]),e._v(" "),a("p",[e._v("但是由于原生提供的 "),a("code",[e._v("requestIdleCallback")]),e._v(" 方法的 "),a("code",[e._v("timeRemaining()")]),e._v(" 最大返回是 50ms，也就是 20fps，达不到页面流畅度的要求，并且该 API 兼容性也比较差。所以 React 团队没有直接使用原生的 requestIdleCallback，而是自己 "),a("a",{attrs:{href:"https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerDOM.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("polyfill"),a("OutboundLink")],1),e._v(" 了一个")]),e._v(" "),a("h3",{attrs:{id:"fiber-特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fiber-特点"}},[e._v("#")]),e._v(" fiber 特点")]),e._v(" "),a("ul",[a("li",[e._v("链表结构 - fiber")]),e._v(" "),a("li",[e._v("循环代替递归（深度优先遍历）——可中断（协程的概念来回交换执行权）")]),e._v(" "),a("li",[e._v("requestIdleCallback/requestAnimateFrame —— 可异步（时间切片把 langtime 分成一段一段小任务）")])]),e._v(" "),a("h2",{attrs:{id:"二、-如何让-react-的-diff-可中断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、-如何让-react-的-diff-可中断"}},[e._v("#")]),e._v(" 二、 如何让 React 的 diff 可中断？")]),e._v(" "),a("p",[e._v("虚拟 dom 是一个树状结构，diff 操作实际上就是递归遍历了一遍这颗树。")]),e._v(" "),a("p",[e._v("不同于前面一直递增到 10000 就结束的简单例子，在递归中中断以及恢复状态很麻烦。如果改成类似链表的结构那就好办很多，可以一直 next，知道 next 为 null 就知道遍历结束了。")]),e._v(" "),a("p",[e._v("也就是说，我们需要将递归操作变成遍历操作，Fiber 恰巧也是这么做的。")]),e._v(" "),a("p",[e._v("::: tips 总结\n总结一下，为了解决 diff 时间过长导致的卡顿问题，React Fiber 用类似 requestIdleCallback 的机制来做异步 diff。但是之前的数据结构不支持这样的实现异步 diff，于是 React 实现了一个类似链表的数据结构，将原来的 递归 diff 变成了现在的 遍历 diff，这样就能方便的做中断和恢复了。\n:::")]),e._v(" "),a("h2",{attrs:{id:"react-fiber-polyfill"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber-polyfill"}},[e._v("#")]),e._v(" React Fiber polyfill")]),e._v(" "),a("p",[e._v("React16.6 之后在任务调度中意图使用 requestIdleCallback 这个函数，但是它的兼容性并不好，Safari、安卓 8.1 以下、IE 等都是重灾区，所以 React 做了一个 Polyfill，它是怎么做的呢？这里简要介绍下 React16.13.1 中实现的步骤。")]),e._v(" "),a("h3",{attrs:{id:"react-如何-polyfill"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-如何-polyfill"}},[e._v("#")]),e._v(" React 如何 polyfill")]),e._v(" "),a("p",[e._v("React 维护了两个小队列 "),a("code",[e._v("taskQueue")]),e._v("和"),a("code",[e._v("timerQueue")]),e._v("，前者保存等待被调度的任务，后者保存调度中的任务，它们的排列依据分别是任务的超时时间和过期时间。到达超时时间的任务会从"),a("code",[e._v("timerQueue")]),e._v("移动到"),a("code",[e._v("taskQueue")]),e._v("中，而在过期时间之内"),a("code",[e._v("taskQueue")]),e._v("中的任务期望得到执行，React 调度的核心主要是以下几点：")]),e._v(" "),a("ol",[a("li",[e._v("何时把超时的任务从"),a("code",[e._v("timerQueue")]),e._v("转移到"),a("code",[e._v("taskQueue")]),e._v("；")]),e._v(" "),a("li",[a("code",[e._v("taskQueue")]),e._v("中任务的执行时机，以及后续任务的衔接；")]),e._v(" "),a("li",[e._v("何时暂停执行任务，把资源回交给浏览器。")])]),e._v(" "),a("p",[e._v("使用 "),a("code",[e._v("unstable_scheduleCallback")]),e._v(" 注册任务的时候可以提供两个参数，"),a("code",[e._v("delay")]),e._v("表示任务的超时时长，"),a("code",[e._v("timeout")]),e._v("表示任务的过期时长（如果没有指定，根据优先程度任务会被分配默认的 timeout 时长）。")]),e._v(" "),a("p",[e._v("如果没有提供"),a("code",[e._v("delay")]),e._v("，则任务被直接放到"),a("code",[e._v("taskQueue")]),e._v("中等待处理；\n如果提供了"),a("code",[e._v("delay")]),e._v("，则任务被放置在"),a("code",[e._v("timerQueue")]),e._v("中，此时如果"),a("code",[e._v("taskQueue")]),e._v("为空，且当前任务在 timerQueue 的堆顶（当前任务的超时时间最近），则使用 "),a("code",[e._v("requestHostTimeout")]),e._v(" 启动定时器（setTimeout），在到达当前任务的超时时间时执行 "),a("code",[e._v("handleTimeout")]),e._v(" ，此函数调用 "),a("code",[e._v("advanceTimers")]),e._v(" 将"),a("code",[e._v("timerQueue")]),e._v("中的任务转移到"),a("code",[e._v("taskQueue")]),e._v("中，此时如果"),a("code",[e._v("taskQueue")]),e._v("没有开启执行则调用 "),a("code",[e._v("requestHostCallback")]),e._v(" 启动它，否则继续递归地执行 "),a("code",[e._v("handleTimeout")]),e._v(" 处理下一个"),a("code",[e._v("timerQueue")]),e._v("中的任务。")]),e._v(" "),a("p",[e._v("旧版react通过递归方式进行渲染，使用的是js的函数调用栈")])])}),[],!1,null,null,null);t.default=_.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{543:function(t,a,s){"use strict";s.r(a);var _=s(2),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http-版本对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-版本对比"}},[t._v("#")]),t._v(" HTTP 版本对比")]),t._v(" "),s("p",[t._v("HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。")]),t._v(" "),s("ul",[s("li",[t._v("HTTP/0.9")]),t._v(" "),s("li",[t._v("HTTP/1.0")]),t._v(" "),s("li",[t._v("HTTP/1.1")]),t._v(" "),s("li",[t._v("HTTP/2")]),t._v(" "),s("li",[t._v("HTTP/3")])]),t._v(" "),s("h2",{attrs:{id:"一、http-0-9"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、http-0-9"}},[t._v("#")]),t._v(" 一、HTTP/0.9")]),t._v(" "),s("p",[t._v("HTTP/0.9 诞生于 1991 年，是 HTTP 协议的最初版，构造十分简单：")]),t._v(" "),s("ul",[s("li",[t._v("请求端只支持 GET 请求")]),t._v(" "),s("li",[t._v("响应端只能返回 HTML 文本数据")])]),t._v(" "),s("p",[t._v("HTTP/0.9 只能发送 GET 请求，且每一个请求都单独创建一个 TCP 连接，响应端只能返回 HTML 格式的数据，响应完成之后 TCP 请求断开。")]),t._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- GET /index.html --\x3e")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    Hello World\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h3",{attrs:{id:"😭-痛点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#😭-痛点"}},[t._v("#")]),t._v(" 😭 痛点：")]),t._v(" "),s("ul",[s("li",[t._v("请求方式唯一，返回格式唯一")]),t._v(" "),s("li",[t._v("TCP 连接无法复用")])]),t._v(" "),s("h2",{attrs:{id:"二、http-1-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、http-1-0"}},[t._v("#")]),t._v(" 二、HTTP/1.0")]),t._v(" "),s("p",[t._v("HTTP/1.0 诞生于 1996 年，它在 HTTP/0.9 的基础上，增加了 HTTP 头部字段，极大扩展了 HTTP 的使用场景。这个版本的 HTTP 不仅可以传输文字，还能传输图像、视频、二进制文件")]),t._v(" "),s("h3",{attrs:{id:"核心特点如下"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心特点如下"}},[t._v("#")]),t._v(" 核心特点如下：")]),t._v(" "),s("ol",[s("li",[t._v("请求端增加 HTTP 协议版本，响应端增加状态码。")]),t._v(" "),s("li",[t._v("请求方法增加 "),s("code",[t._v("POST、HEAD")]),t._v("。")]),t._v(" "),s("li",[t._v("请求端和响应端增加头部字段。\n"),s("ul",[s("li",[s("code",[t._v("Content-Type")]),t._v(" 让响应数据不只限于超文本。")]),t._v(" "),s("li",[s("code",[t._v("Expires")]),t._v("、"),s("code",[t._v("Last-Modified")]),t._v(" 缓存头。")]),t._v(" "),s("li",[s("code",[t._v("Authorization")]),t._v(" 身份认证。")]),t._v(" "),s("li",[s("code",[t._v("Connection")]),t._v(": "),s("code",[t._v("keep-alive")]),t._v(" 支持长连接，但非标准。")])])])]),t._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!-- GET /my page.html HTTP/1.0\nUser-Agent: N CSA_Mosaic/2.0 (Windows 3.1)\n200 OK\nDate: Tue, 15 Nov 1994 08:12:31 GMT\nServer: CERN/3.0 lib www/2.17\nContent-Type: text/html --\x3e")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    Hello World\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("HTTP/1.0 扩展了请求方法和响应状态码，并且支持定义 HTTP 头部字段，通过 Content-Type 头，我们就能传输任何格式的数据了。同时，HTTP/1.0 仍然是一个请求对应一个 TCP 连接，不能形成复用。")]),t._v(" "),s("h3",{attrs:{id:"😭-痛点-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#😭-痛点-2"}},[t._v("#")]),t._v(" 😭 痛点：")]),t._v(" "),s("ul",[s("li",[t._v("TCP 连接无法复用。")]),t._v(" "),s("li",[t._v("队头阻塞，一个 HTTP 请求响应结束之后，才能发起下一个 HTTP 请求。")]),t._v(" "),s("li",[t._v("一台服务器只能提供一个 HTTP 服务。")])]),t._v(" "),s("h2",{attrs:{id:"三、http-1-1"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、http-1-1"}},[t._v("#")]),t._v(" 三、HTTP/1.1")]),t._v(" "),s("p",[t._v("HTTP/1.1 诞生于 1999 年")]),t._v(" "),s("p",[t._v("💗 "),s("strong",[t._v("核心特点如下")]),t._v(" 👇👇👇👇👇👇")]),t._v(" "),s("h3",{attrs:{id:"_1、-持久连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、-持久连接"}},[t._v("#")]),t._v(" 1、 持久连接")]),t._v(" "),s("p",[t._v("HTTP/1.1 默认开启持久连接，在 TCP 连接建立后不立即关闭，让多个 HTTP 请求得以复用。")]),t._v(" "),s("h3",{attrs:{id:"_2、管线化技术"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、管线化技术"}},[t._v("#")]),t._v(" 2、管线化技术")]),t._v(" "),s("p",[t._v("多个 HTTP 请求不用排队发送，可以批量发送，解决了 HTTP 队头阻塞问题，但是，😿 必须按照发送的顺序返回响应")]),t._v(" "),s("h3",{attrs:{id:"_3、支持响应分块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、支持响应分块"}},[t._v("#")]),t._v(" 3、支持响应分块")]),t._v(" "),s("ul",[s("li",[t._v("实现了流式渲染，响应端可以不用一次返回所有数据，可以将数据拆分成多个模块，产生一块数据，就发送一块数据，这样客户端就可以同步对数据进行处理，减少响应延迟，降低白屏时间。")]),t._v(" "),s("li",[s("code",[t._v("Big pipe")]),t._v(" 的实现就是基于这个特性，具体是通过定义 "),s("code",[t._v("Transfer-Encoding")]),t._v(" 头来实现的。")])]),t._v(" "),s("h3",{attrs:{id:"_4、增加-host-头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、增加-host-头"}},[t._v("#")]),t._v(" 4、增加 Host 头")]),t._v(" "),s("ul",[s("li",[t._v("实现了虚拟主机技术，将一台服务器分成若干个主机，这样就可以在一台服务器上部署多个网站了")]),t._v(" "),s("li",[t._v("通过配置 Host 的域名和端口号，即可支持多个 HTTP 服务："),s("code",[t._v("Host: <domain>:<port>")])])]),t._v(" "),s("h3",{attrs:{id:"_5、其他扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、其他扩展"}},[t._v("#")]),t._v(" 5、其他扩展")]),t._v(" "),s("ol",[s("li",[t._v("增加 Cache-Control、E-Tag 缓存头。")]),t._v(" "),s("li",[t._v("增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 请求方法。")])]),t._v(" "),s("h3",{attrs:{id:"😭-痛点-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#😭-痛点-3"}},[t._v("#")]),t._v(" 😭 痛点：")]),t._v(" "),s("p",[t._v("HTTP 队头阻塞没有彻底解决，响应端必须按照 HTTP 的发送顺序进行返回，如果排序靠前的响应特别耗时，则会阻塞排序靠后的所有响应。")]),t._v(" "),s("h2",{attrs:{id:"四、http-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、http-2"}},[t._v("#")]),t._v(" 四、HTTP/2")]),t._v(" "),s("p",[t._v("HTTP/2 诞生于 2015 年，它的最大的特点是使用 "),s("strong",[t._v("二进制")])]),t._v(" "),s("p",[t._v("👀 HTTP/2 将一个 HTTP 请求划分为 3 个部分")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("帧")]),t._v("：一段二进制数据，是 HTTP/2 传输的最小单位。")]),t._v(" "),s("li",[s("strong",[t._v("消息")]),t._v("：一个请求或响应对应的一个或多个帧。")]),t._v(" "),s("li",[s("strong",[t._v("数据流")]),t._v("：已建立的连接内的双向字节流，可以承载一条或多条消息")])]),t._v(" "),s("p",[t._v("一个 TCP 连接上有多个数据流，一个数据流承载着双向消息，一条消息包含了多个帧，每个帧都有唯一的标识，指向所在的数据流，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装，这样就实现了数据传输。")]),t._v(" "),s("p",[t._v("💗 "),s("strong",[t._v("HTTP/2 核心特点")]),t._v(" 👇👇👇👇👇👇")]),t._v(" "),s("h3",{attrs:{id:"_1、请求优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、请求优先级"}},[t._v("#")]),t._v(" 1、请求优先级")]),t._v(" "),s("p",[t._v("多个 HTTP 请求同时发送时，会产生多个数据流，数据流中有一个优先级的标识，服务器端可以根据这个标识来决定响应的优先顺序。")]),t._v(" "),s("h3",{attrs:{id:"_2、多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、多路复用"}},[t._v("#")]),t._v(" 2、多路复用")]),t._v(" "),s("p",[t._v("TCP 传输时，不用按照 HTTP 的发送顺序进行响应，可以交错发送，接收端根据帧首部的标识符，就能找到对应的流，进而重新组合得到最终数据")]),t._v(" "),s("h3",{attrs:{id:"_3、服务器端推送"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、服务器端推送"}},[t._v("#")]),t._v(" 3、服务器端推送")]),t._v(" "),s("ul",[s("li",[t._v("HTTP/2 允许服务器未经请求，主动向客户端发送资源，并缓存到客户端中，以避免二次请求。")]),t._v(" "),s("li",[t._v("HTTP/1.1 中请求一个页面时，浏览器会先发送一个 HTTP 请求，然后得到响应的 HTML 内容并开始解析，如果发现有 "),s("code",[t._v('<script src="xxxx.js">')]),t._v("标签，则会再次发起 HTTP 请求获取对应的 JS 内容。而 HTTP/2 可以在返回 HTML 的同时，将需要用到的 JS、CSS 等内容一并返回给客户端，当浏览器解析到对应标签时，也就不需要再次发起请求了。")])]),t._v(" "),s("h3",{attrs:{id:"_4、头部压缩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、头部压缩"}},[t._v("#")]),t._v(" 4、头部压缩")]),t._v(" "),s("ul",[s("li",[t._v("HTTP/1.1 的头部字段包含大量信息，而且每次请求都得带上，占用了大量的字节。")]),t._v(" "),s("li",[t._v("HTTP/2.0 中通信双方各自缓存一份头部字段表，如：把 "),s("code",[t._v("Content-Type:text/html")]),t._v(" 存入索引表中，后续如果要用到这个头，只需要发送对应的索引号就可以了")])]),t._v(" "),s("h3",{attrs:{id:"_5、安全性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、安全性"}},[t._v("#")]),t._v(" 5、安全性")]),t._v(" "),s("p",[t._v('HTTP/2 是加密的。也就是说，互联网上通常所能见到的 HTTP/2 都是使用"https”协议名，跑在 TLS 上面。HTTP/2 协议定义了两个字符串标识符：“h2"表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2。')]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("在 HTTP/2 中发送请求时，既不需要排队发送，也不需要排队返回，彻底解决了 HTTP 队头阻塞问题。对于头部信息，资源缓存等痛点也进行了优化，似乎已经是一种很完美的方案了。")]),t._v(" "),s("p",[t._v("HTTP/2 在 HTTP + TCP 的架构上已经优化到了极致，如果要想继续优化，那就只能从这个架构入手了")]),t._v(" "),s("p",[t._v("😭 首先需要优化的是 TCP，因为 TCP 核心是保证传输层的可靠性，传输效率其实并不好")]),t._v(" "),s("ol",[s("li",[t._v("TCP 也存在"),s("strong",[t._v("队头阻塞")]),t._v("，TCP 在传输时使用序列号标识数据的顺序，一旦某个数据丢失，后面的数据需要等待这个数据重传后才能进行下一步处理")]),t._v(" "),s("li",[t._v("TCP 每一次建立都需要"),s("strong",[t._v("三次握手")]),t._v("，释放连接需要四次挥手，无形中增加了传输时长")]),t._v(" "),s("li",[t._v("TCP 存在"),s("strong",[t._v("拥塞控制")]),t._v("，内置了慢启动，拥塞避免等算法，传输效率并不稳定")])]),t._v(" "),s("p",[t._v("如果要解决这些问题，就需要替换掉 TCP，而这也是 HTTP/3 的解决思路")]),t._v(" "),s("h2",{attrs:{id:"五、http-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、http-3"}},[t._v("#")]),t._v(" 五、HTTP/3")]),t._v(" "),s("p",[t._v("HTTP/3 目前还在草案阶段，它的主要特点是对传输层进行了优化，使用 QUIC 替换 TCP，彻底规避了 TCP 传输的效率问题")]),t._v(" "),s("p",[t._v("QUIC 由 Google 提出的基于 UDP 进行多路复用的传输协议。QUIC 没有连接的概念，不需要三次握手，在应用程序层面，实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性。在设备支持层面，只需要客户端和服务端的应用程序支持 QUIC 协议即可，无操作系统和中间设备的限制")]),t._v(" "),s("p",[t._v("💗 "),s("strong",[t._v("HTTP/3 核心特点")]),t._v(" 👇👇👇👇👇👇")]),t._v(" "),s("h3",{attrs:{id:"_1、传输层连接更快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、传输层连接更快"}},[t._v("#")]),t._v(" 1、传输层连接更快")]),t._v(" "),s("p",[t._v("HTTP/3 基于 QUIC 协议，可以实现 0-RTT 建立连接，而 TCP 需要 3-RTT 才能建立连接")]),t._v(" "),s("h3",{attrs:{id:"_2、传输层多路复用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、传输层多路复用"}},[t._v("#")]),t._v(" 2、传输层多路复用")]),t._v(" "),s("ul",[s("li",[t._v("Stream 之间相互独立，丢了一个，不会影响到其他的")]),t._v(" "),s("li",[t._v("HTTP/3 传输层使用 QUIC 协议，数据在传输时会被拆分成了多个 packet 包，每一个 packet 包都可以独立、交错发送，不用按顺序发送，也就避免了 TCP 队头阻塞")])]),t._v(" "),s("h3",{attrs:{id:"_3、改进的拥塞控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、改进的拥塞控制"}},[t._v("#")]),t._v(" 3、改进的拥塞控制")]),t._v(" "),s("h3",{attrs:{id:"_4、优化的流量控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、优化的流量控制"}},[t._v("#")]),t._v(" 4、优化的流量控制")]),t._v(" "),s("ul",[s("li",[t._v("Stream 级别的流量控制中，接收窗口 = 最大接收窗口- 已接收数据。")]),t._v(" "),s("li",[t._v("Connection 级别的流量控制中，接收窗口 = Stream1 接收窗口 + Stream2 接收窗口 + ... + StreamN 接收窗口。")]),t._v(" "),s("li",[t._v("TCP 通过滑动窗口来控制流量，如果某一个包丢失了，滑动窗口并不能跨过丢失的包继续滑动，而是会卡在丢失的位置，等待数据重传后，才能继续滑动。")]),t._v(" "),s("li",[t._v("QUIC 流量控制的核心是："),s("strong",[t._v("不能建立太多的连接，以免响应端处理不过来；不能让某一个连接占用大量的资源，让其他连接没有资源可用")]),t._v("。为此 QUIC 流量控制分为 2 个级别：连接级别（Connection Level）和 Stream 级别（Stream Level）")])]),t._v(" "),s("h3",{attrs:{id:"_5、加密认证的报文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、加密认证的报文"}},[t._v("#")]),t._v(" 5、加密认证的报文")]),t._v(" "),s("ul",[s("li",[t._v("QUIC 中报文都是经过加密和认证的，在传输过程中保证了数据的安全。")]),t._v(" "),s("li",[t._v("TCP 头部没有经过任何加密和认证，在传输过程中很容易被中间网络设备篡改，注入和窃听")])]),t._v(" "),s("h3",{attrs:{id:"_6、连接迁移"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、连接迁移"}},[t._v("#")]),t._v(" 6、连接迁移")]),t._v(" "),s("ul",[s("li",[t._v("QUIC 使用客户端生成的 64 位 ID 来表示一条连接，只要 ID 不变，这条连接也就一直维持着，不会中断。")]),t._v(" "),s("li",[t._v("TCP 连接是由（源 IP，源端口，目的 IP，目的端口）组成，这四者中一旦有一项发生改变，这个连接也就不能用了。如果我们从 5G 网络切换到 WiFi 网络，IP 地址就会改变，这个时候 TCP 连接也自然断掉了。")])]),t._v(" "),s("h3",{attrs:{id:"_7、前向纠错机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、前向纠错机制"}},[t._v("#")]),t._v(" 7、前向纠错机制")]),t._v(" "),s("ul",[s("li",[t._v("发送端需要发送三个包，QUIC 在传输时会计算出这三个包的异或值，并单独发出一个校验包，也就是总共发出了四个包。")]),t._v(" "),s("li",[t._v("如果某一个包（非校验包）传输时丢失了，则可以通过另外三个包计算出丢失数据包的内容。")]),t._v(" "),s("li",[t._v("当然这种技术只能用在丢失一个包的情况下，如果丢失了多个包，就只能进行重传了。")]),t._v(" "),s("li",[t._v("QUIC 中发送数据时，除了发送本身的数据包，还会发送验证包，以减少数据丢失导致的重传")])]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("QUIC 丢掉了 TCP 的包袱，基于 UDP，实现了一个安全高效可靠的 HTTP 通信协议。凭借着 0-RTT 建立连接、传输层多路复用、连接迁移、改进的拥塞控制、流量控制等特性，QUIC 在绝大多数场景下获得了比 HTTP/2 更好的效果")]),t._v(" "),s("h2",{attrs:{id:"总结-🐼"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结-🐼"}},[t._v("#")]),t._v(" 总结 🐼")]),t._v(" "),s("ol",[s("li",[t._v("HTTP/0.9 实现基本请求响应。")]),t._v(" "),s("li",[t._v("HTTP/1.0 增加 HTTP 头，丰富传输资源类型，奠定互联网发展基础。")]),t._v(" "),s("li",[t._v("HTTP/1.1 增加持久连接、管线化、响应分块，提升了 HTTP 传输效率。")]),t._v(" "),s("li",[t._v("HTTP/2 采用二进制传输格式，通过 HTTP 多路复用、头部压缩、服务器端推送，将传输效率在 HTTP + TCP 架构上发挥到了极致。")]),t._v(" "),s("li",[t._v("HTTP/3 将传输层替换为 QUIC，通过改进的拥塞控制、流量控制、0-RTT 建连、传输层多路复用、连接迁移等特性，进一步提升了 HTTP 传输效率。")])]),t._v(" "),s("p",[t._v("可以看到，从 HTTP/1.1 开始，HTTP 的发展方向就是：不断地提升传输效率")])])}),[],!1,null,null,null);a.default=v.exports}}]);
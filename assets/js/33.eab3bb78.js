(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{538:function(v,_,t){"use strict";t.r(_);var a=t(2),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[v._v("#")]),v._v(" 作用域")]),v._v(" "),t("p",[v._v("变量的作用域无非就是两种：全局变量和局部变量。")]),v._v(" "),t("h2",{attrs:{id:"什么是作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是作用域"}},[v._v("#")]),v._v(" 什么是作用域")]),v._v(" "),t("h2",{attrs:{id:"全局作用域和函数作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域和函数作用域"}},[v._v("#")]),v._v(" 全局作用域和函数作用域")]),v._v(" "),t("h2",{attrs:{id:"块级作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[v._v("#")]),v._v(" 块级作用域")]),v._v(" "),t("p",[v._v("let const")]),v._v(" "),t("h2",{attrs:{id:"作用域链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[v._v("#")]),v._v(" 作用域链")]),v._v(" "),t("p",[v._v("查找变量的时候，会从当前上下文环境记录中查找，如果没有找到，就会从上级执行上下文环境记录中查找，一直找到全局上下文的环境记录，这样多个执行上下文环境的记录构成的链表，就是作用域链")]),v._v(" "),t("h2",{attrs:{id:"执行上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[v._v("#")]),v._v(" 执行上下文")]),v._v(" "),t("p",[v._v("解释阶段：")]),v._v(" "),t("ul",[t("li",[v._v("词法分析")]),v._v(" "),t("li",[v._v("语法分析")]),v._v(" "),t("li",[v._v("作用域规则确定")])]),v._v(" "),t("p",[v._v("执行阶段：")]),v._v(" "),t("ul",[t("li",[v._v("创建执行上下文")]),v._v(" "),t("li",[v._v("执行函数代码")]),v._v(" "),t("li",[v._v("垃圾回收")])]),v._v(" "),t("p",[v._v("作用域和执行上下文之间最大的区别是：")]),v._v(" "),t("p",[v._v("执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变")]),v._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[v._v("#")]),v._v(" 闭包")]),v._v(" "),t("blockquote",[t("p",[v._v("当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 --- 你不知道的JavaScript(上卷)")])]),v._v(" "),t("p",[v._v("闭包就是能够读取其他函数内部变量的函数，所以，闭包就是将函数内部和函数外部连接起来的一座桥梁")]),v._v(" "),t("p",[v._v("用途：")]),v._v(" "),t("ol",[t("li",[v._v("可以读取函数内部的变量")]),v._v(" "),t("li",[v._v("让这些变量的值始终保持在内存中，保护变量不被污染")]),v._v(" "),t("li",[v._v("通过闭包来模拟私有方法（私有方法只能被一个类中的其他方法所调用，但是 JavaScript 没有提供这种原生支持）")]),v._v(" "),t("li",[v._v("避免变量污染全局")])]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("ol",[t("li",[v._v("使用不当会导致内存泄漏。内部函数保存了外部变量的引用，导致无法被垃圾回收，增大了内存使用")]),v._v(" "),t("li",[v._v("对处理速度有影响。引用外部变量经过了作用域链的长度")])]),v._v(" "),t("h3",{attrs:{id:"闭包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包原理"}},[v._v("#")]),v._v(" 闭包原理")]),v._v(" "),t("p",[v._v("函数执行分为 "),t("strong",[v._v("预编译阶段")]),v._v(" 和 "),t("strong",[v._v("执行阶段")])]),v._v(" "),t("ul",[t("li",[v._v("在预编译阶段，如果内部函数 使用了 外部函数的变量，则会在内存中创建一个'闭包对象'并保存对应变量值")]),v._v(" "),t("li",[v._v("执行完成之后，函数执行上下文会被销毁，函数对‘闭包对象’的引用也会被销毁，但其内部函数还持有该'闭包对象'的引用，所以内部函数可以继续使用外部函数中的变量")])]),v._v(" "),t("p",[v._v("闭包利用了函数作用域链的特性，一个函数内部定义的函数，会将包含外部函数的活动对象添加到它的作用域链中，函数执行完毕，其执行作用域链销毁，但因内部函数的作用域链任在引用这个活动对象，所以其活动的对象不会被销毁，直到内部函数被销毁才被销毁")])])}),[],!1,null,null,null);_.default=r.exports}}]);
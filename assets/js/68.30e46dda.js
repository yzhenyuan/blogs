(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{585:function(t,e,s){"use strict";s.r(e);var a=s(2),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[t._v("#")]),t._v(" 生命周期")]),t._v(" "),s("p",[t._v("react 16 版本 生命周期 一共分为四个阶段")]),t._v(" "),s("ol",[s("li",[t._v("初始化")]),t._v(" "),s("li",[t._v("运行中")]),t._v(" "),s("li",[t._v("销毁")]),t._v(" "),s("li",[t._v("错误处理（16 版之后新增）：componentDidCatch(error, info)")])]),t._v(" "),s("h2",{attrs:{id:"一、初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、初始化"}},[t._v("#")]),t._v(" 一、初始化")]),t._v(" "),s("ul",[s("li",[t._v("constructor() 用来做一些组件的初始化工作，如定义 this.state 的初始内容")]),t._v(" "),s("li",[t._v("super(props)用来调用基类的构造方法( constructor() ), 也将父组件的 props 注入给子组件（组件中 props 只读不可变，state 可变）")])]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Component")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h2",{attrs:{id:"二、挂载阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、挂载阶段"}},[t._v("#")]),t._v(" 二、挂载阶段")]),t._v(" "),s("p",[t._v("这个阶段分三个时期")]),t._v(" "),s("ol",[s("li",[t._v("componentWillMount")]),t._v(" "),s("li",[t._v("render")]),t._v(" "),s("li",[t._v("componentDidMount")])]),t._v(" "),s("h3",{attrs:{id:"_2-1-componentwillmount"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-componentwillmount"}},[t._v("#")]),t._v(" 2.1 componentWillMount")]),t._v(" "),s("ul",[s("li",[t._v("在组件挂载到 DOM 前调用，且只会被调用一次")]),t._v(" "),s("li",[t._v("在这边调用 this.setState 不会引起组件重新渲染，也可以把写在这边的内容提前到 constructor()中，所以项目中很少用")])]),t._v(" "),s("h3",{attrs:{id:"_2-2-render"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-render"}},[t._v("#")]),t._v(" 2.2 render")]),t._v(" "),s("ul",[s("li",[t._v("根据组件的 "),s("code",[t._v("props")]),t._v(" 和 "),s("code",[t._v("state")]),t._v(" ，返回一个 react 元素，用于描述组件的 UI")]),t._v(" "),s("li",[t._v("并不负责组件的实际渲染工作，真正的渲染 DOM 的工作，由 react 自身根据此元素去负责")]),t._v(" "),s("li",[s("code",[t._v("render")]),t._v(" 是纯函数，不能在里面执行 "),s("code",[t._v("this.setState")]),t._v("，会有改变组件状态的副作用")]),t._v(" "),s("li",[t._v("shouldComponentUpdate 返回 false，render 不会被调用")])]),t._v(" "),s("h3",{attrs:{id:"_2-3-componentdidmount"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-componentdidmount"}},[t._v("#")]),t._v(" 2.3 componentDidMount")]),t._v(" "),s("ul",[s("li",[t._v("组件挂载到 DOM 后调用，且只会被调用一次")])]),t._v(" "),s("h2",{attrs:{id:"三、更新阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、更新阶段"}},[t._v("#")]),t._v(" 三、更新阶段")]),t._v(" "),s("p",[t._v("这个阶段会"),s("strong",[t._v("根据条件")]),t._v("触发下面几个钩子")]),t._v(" "),s("ol",[s("li",[t._v("componentWillReceiveProps")]),t._v(" "),s("li",[t._v("shouldComponentUpdate")]),t._v(" "),s("li",[t._v("componentWillUpdate")]),t._v(" "),s("li",[t._v("render 这边只是"),s("strong",[t._v("重新调用")])]),t._v(" "),s("li",[t._v("componentDidUpdate")])]),t._v(" "),s("h3",{attrs:{id:"_3-1-componentwillreceiveprops-nextprops"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-componentwillreceiveprops-nextprops"}},[t._v("#")]),t._v(" 3.1 componentWillReceiveProps(nextProps)")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("props")]),t._v("的更新会触发这个钩子")]),t._v(" "),s("li",[t._v("参数"),s("code",[t._v("nextProps")]),t._v("是父组件传给当前组件的新"),s("code",[t._v("props")])])]),t._v(" "),s("h3",{attrs:{id:"_3-2-shouldcomponentupdate-nextprops-nextstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-shouldcomponentupdate-nextprops-nextstate"}},[t._v("#")]),t._v(" 3.2 shouldComponentUpdate(nextProps, nextState)")]),t._v(" "),s("ul",[s("li",[t._v("通过比较 nextProps，nextState 及当前组件的 this.props，this.state")]),t._v(" "),s("li",[t._v("返回 true 时当前组件将继续执行更新过程，返回 false 则当前组件更新停止，")]),t._v(" "),s("li",[t._v("以此可用来减少组件的不必要渲染，优化组件性能。")])]),t._v(" "),s("h3",{attrs:{id:"_3-3-componentwillupdate-nextprops-nextstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-componentwillupdate-nextprops-nextstate"}},[t._v("#")]),t._v(" 3.3 componentWillUpdate(nextProps, nextState)")]),t._v(" "),s("p",[t._v("此方法在调用 render 方法前执行，在这边可执行一些组件更新发生前的工作")]),t._v(" "),s("h3",{attrs:{id:"_3-4-render"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-render"}},[t._v("#")]),t._v(" 3.4 render")]),t._v(" "),s("p",[t._v("只是"),s("strong",[t._v("重新调用")])]),t._v(" "),s("h3",{attrs:{id:"_3-5-componentdidupdate-prevprops-prevstate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-componentdidupdate-prevprops-prevstate"}},[t._v("#")]),t._v(" 3.5 componentDidUpdate(prevProps, prevState)")]),t._v(" "),s("ul",[s("li",[t._v("此方法在组件更新后被调用，可以操作组件更新的 DOM")]),t._v(" "),s("li",[t._v("prevProps 和 prevState 这两个参数指的是组件更新前的 props 和 state")])]),t._v(" "),s("h2",{attrs:{id:"四、错误处理阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、错误处理阶段"}},[t._v("#")]),t._v(" 四、错误处理阶段")]),t._v(" "),s("h3",{attrs:{id:"componentdidcatch-error-info"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#componentdidcatch-error-info"}},[t._v("#")]),t._v(" componentDidCatch(error, info)")]),t._v(" "),s("p",[t._v("组件抛出错误后被调用")]),t._v(" "),s("ul",[s("li",[t._v("error：错误信息")]),t._v(" "),s("li",[t._v("info：包含有关组件引发错误的栈信息")])]),t._v(" "),s("h2",{attrs:{id:"五、新的的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、新的的生命周期"}},[t._v("#")]),t._v(" 五、新的的生命周期")]),t._v(" "),s("h3",{attrs:{id:"_5-1-修改的哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-修改的哪些"}},[t._v("#")]),t._v(" 5.1 修改的哪些？")]),t._v(" "),s("p",[t._v("新增：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("static getDerivedStateFromProps")])]),t._v(" "),s("li",[s("code",[t._v("getSnapshotBeforeUpdate")])])]),t._v(" "),s("p",[t._v("废弃：")]),t._v(" "),s("ul",[s("li",[t._v("componentWillMount")]),t._v(" "),s("li",[t._v("componentWillReceiveProps")]),t._v(" "),s("li",[t._v("componentWillUpdate")])]),t._v(" "),s("h3",{attrs:{id:"_5-2-改变生命周期的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-改变生命周期的原因"}},[t._v("#")]),t._v(" 5.2 改变生命周期的原因")]),t._v(" "),s("ol",[s("li",[s("code",[t._v("fiber")]),t._v(" 的出现会因为高优先级任务的出现导致它们会执行多次")]),t._v(" "),s("li",[t._v("为了约束开发者")])]),t._v(" "),s("h4",{attrs:{id:"_1-componentwillmount"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-componentwillmount"}},[t._v("#")]),t._v(" ① componentWillMount")]),t._v(" "),s("p",[t._v("完全可以用 DidMount 和 constructor 来代替")]),t._v(" "),s("h4",{attrs:{id:"_2-componentwillreceiveprops"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-componentwillreceiveprops"}},[t._v("#")]),t._v(" ② componentWillReceiveProps")]),t._v(" "),s("ul",[s("li",[t._v("会破坏数据的单一数据源")]),t._v(" "),s("li",[t._v("增加组件的重绘次数")])]),t._v(" "),s("h4",{attrs:{id:"_3-receiveprops-跟-getderivedstatefromprops-的对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-receiveprops-跟-getderivedstatefromprops-的对比"}},[t._v("#")]),t._v(" ③ ReceiveProps 跟 getDerivedStateFromProps 的对比")]),t._v(" "),s("p",[t._v("getDerivedStateFromProps 的特点：")]),t._v(" "),s("ol",[s("li",[t._v("是一个纯函数，不能写副作用")]),t._v(" "),s("li",[t._v("只能通过 prevState 来做对比，不需要处理第一次 prevProps 为空的情况")]),t._v(" "),s("li",[t._v("将状态变化跟操作分开")])]),t._v(" "),s("h4",{attrs:{id:"_4-componentwillupdate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-componentwillupdate"}},[t._v("#")]),t._v(" ④ componentWillUpdate")]),t._v(" "),s("p",[t._v("跟 componentWillReceiveProps 类似")]),t._v(" "),s("h4",{attrs:{id:"_5-getsnapshotbeforeupdate"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-getsnapshotbeforeupdate"}},[t._v("#")]),t._v(" ⑤ getSnapshotBeforeUpdate")]),t._v(" "),s("p",[t._v("会在最终确定 render 执行之前 执行 ，也就是能确保获取到的元素 跟 DidUpdate 中拿到的元素状态相同")])])}),[],!1,null,null,null);e.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{534:function(a,s,t){"use strict";t.r(s);var e=t(2),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"js-基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-基础"}},[a._v("#")]),a._v(" js 基础")]),a._v(" "),t("h2",{attrs:{id:"一、原型和原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、原型和原型链"}},[a._v("#")]),a._v(" 一、原型和原型链")]),a._v(" "),t("p",[a._v("想了解原型需要从 JS 这门语言的设计初衷开始来理解")]),a._v(" "),t("h3",{attrs:{id:"js-诞生及及设计初衷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-诞生及及设计初衷"}},[a._v("#")]),a._v(" js 诞生及及设计初衷")]),a._v(" "),t("p",[a._v("1994 年网景公司开发出了第一个网络浏览器，但是整个页面没有任何可以好访问者交互的能力")]),a._v(" "),t("p",[a._v("🆚 例如：表单提交，没有任何验证，什么都不输入然后提交表单后，就只能靠服务端返回信息提示，太消耗网络资源")]),a._v(" "),t("p",[a._v("然后就急需一门网页脚本语言，使得浏览器可以与网页互动")]),a._v(" "),t("p",[a._v("工程师 Brendan Eich 负责开发这种新语言。他觉得，没必要设计得很复杂，这种语言只要能够完成一些简单操作就够了，比如判断用户有没有填写表单")]),a._v(" "),t("h3",{attrs:{id:"js都是对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js都是对象"}},[a._v("#")]),a._v(" js都是对象")]),a._v(" "),t("p",[a._v("1994 年正是面向对象编程最兴盛的时期，Brendan Eich 无疑受到了影响，"),t("strong",[a._v("Javascript 里面所有的数据类型都是对象（object）")]),a._v("，这一点与 Java 非常相似。但是，他随即就遇到了一个难题")]),a._v(" "),t("p",[a._v("❓ 到底要不要设计"),t("strong",[a._v("继承机制")]),a._v("呢 (O_o)??")]),a._v(" "),t("ul",[t("li",[a._v('如果真的是一种简易的脚本语言，其实不需要有"继承"机制')]),a._v(" "),t("li",[a._v("但是，Javascript 里面都是对象，必须有一种机制，将所有对象联系起来")])]),a._v(" "),t("p",[a._v('但是，他不打算引入"类"（class）的概念，因为一旦有了"类"，Javascript 就是一种完整的面向对象编程语言了，违背了一开始的设计初衷')]),a._v(" "),t("h3",{attrs:{id:"new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new"}},[a._v("#")]),a._v(" new")]),a._v(" "),t("p",[a._v("他考虑到，C++和Java语言都使用new命令，生成实例。")]),a._v(" "),t("p",[a._v("C++的写法是：")]),a._v(" "),t("div",{staticClass:"language-c++ line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("　　ClassName *object = new ClassName(param);\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("Java的写法是：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("　　"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Foo")]),a._v(" foo "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[a._v("因此，他就把new命令引入了Javascript，用来从原型对象生成一个实例对象。")]),a._v(" "),t("p",[a._v('但是，Javascript没有"类"，怎么来表示原型对象呢？')]),a._v(" "),t("h3",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),t("p",[a._v('这时，他想到 C++和 Java 使用 new 命令时，都会调用"类"的构造函数（constructor）。他就做了一个简化的设计，在 Javascript 语言中，new 命令后面跟的不是类，而是构造函数。')]),a._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 构造函数")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("DOG")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[a._v("name")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//🚗 示例对象 this")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 对这个构造函数使用 new，就会生成一个狗对象的 实例。")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" dogA "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DOG")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[a._v("'大毛'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br")])]),t("p",[a._v("📚构造函数来表示对象的原型📚")]),a._v(" "),t("p",[a._v("😢 缺点："),t("strong",[a._v("无法共享属性和方法")])]),a._v(" "),t("p",[a._v("每一个实例对象，都有自己的属性和方法的副本。这不仅无法做到数据共享，也是极大的资源浪费。")]),a._v(" "),t("h3",{attrs:{id:"prototype属性的引入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prototype属性的引入"}},[a._v("#")]),a._v(" prototype属性的引入")]),a._v(" "),t("p",[a._v("考虑到这一点，Brendan Eich决定为构造函数设置一个"),t("code",[a._v("prototype")]),a._v("属性。")]),a._v(" "),t("p",[a._v("这个属性包含一个对象，所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。")]),a._v(" "),t("p",[a._v("实例对象一旦创建，将自动引用prototype对象的属性和方法。")]),a._v(" "),t("p",[a._v("也就是说，实例对象的属性和方法，分成两种：①一种是本地的，②另一种是引用的。")]),a._v(" "),t("h3",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("p",[a._v('由于所有的实例对象共享同一个prototype对象，那么从外界看起来，prototype对象就好像是实例对象的原型，而实例对象则好像"继承"了prototype对象一样。')]),a._v(" "),t("h3",{attrs:{id:"_1-1-原型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-原型"}},[a._v("#")]),a._v(" 1.1 原型")]),a._v(" "),t("h3",{attrs:{id:"_1-2-原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-原型链"}},[a._v("#")]),a._v(" 1.2 原型链")]),a._v(" "),t("h2",{attrs:{id:"二、作用域和作用域链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、作用域和作用域链"}},[a._v("#")]),a._v(" 二、作用域和作用域链")]),a._v(" "),t("h2",{attrs:{id:"闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[a._v("#")]),a._v(" 闭包")]),a._v(" "),t("h2",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")])])}),[],!1,null,null,null);s.default=r.exports}}]);
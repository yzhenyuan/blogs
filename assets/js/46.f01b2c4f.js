(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{556:function(v,_,t){"use strict";t.r(_);var a=t(2),r=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"v8-引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎"}},[v._v("#")]),v._v(" V8 引擎")]),v._v(" "),t("h2",{attrs:{id:"一、垃圾回收机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、垃圾回收机制"}},[v._v("#")]),v._v(" 一、垃圾回收机制")]),v._v(" "),t("p",[v._v("v8 引擎将内存分为了新生代和老生代。")]),v._v(" "),t("h3",{attrs:{id:"新生代和老生代。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代和老生代。"}},[v._v("#")]),v._v(" 新生代和老生代。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("新生代")]),v._v("：新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经")]),v._v(" "),t("li",[t("strong",[v._v("老生代")]),v._v("：历过多次垃圾回收的对象被称为老生代。")])]),v._v(" "),t("p",[v._v("新生代被分为 From 和 To 两个空间，To 一般是闲置的。")]),v._v(" "),t("p",[v._v("当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。")]),v._v(" "),t("p",[v._v("当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。")]),v._v(" "),t("p",[v._v("这个算法分为三步：")]),v._v(" "),t("ol",[t("li",[v._v("首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间")]),v._v(" "),t("li",[v._v("如果对象不存活，则释放对象的空间")]),v._v(" "),t("li",[v._v("最后将 From 空间和 To 空间角色进行交换。")])]),v._v(" "),t("h4",{attrs:{id:"新生代对象晋升到老生代有两个条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代对象晋升到老生代有两个条件"}},[v._v("#")]),v._v(" 新生代对象晋升到老生代有两个条件：")]),v._v(" "),t("ol",[t("li",[v._v("第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。")]),v._v(" "),t("li",[v._v("第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。")])]),v._v(" "),t("p",[v._v("老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。")]),v._v(" "),t("p",[v._v("由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。")]),v._v(" "),t("h2",{attrs:{id:"二、执行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、执行机制"}},[v._v("#")]),v._v(" 二、执行机制")]),v._v(" "),t("p",[v._v("V8 执行一段 JavaScript 代码所经历的主要流程包括：")]),v._v(" "),t("ul",[t("li",[v._v("初始化基础环境；")]),v._v(" "),t("li",[v._v("解析源码生成 AST 和作用域；")]),v._v(" "),t("li",[v._v("依据 AST 和作用域生成字节码；")]),v._v(" "),t("li",[v._v("解释执行字节码；")]),v._v(" "),t("li",[v._v("监听热点代码；")]),v._v(" "),t("li",[v._v("优化热点代码为二进制的机器代码；")]),v._v(" "),t("li",[v._v("反优化生成的二进制机器代码。")])]),v._v(" "),t("h2",{attrs:{id:"三、libuv"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、libuv"}},[v._v("#")]),v._v(" 三、libuv")]),v._v(" "),t("h2",{attrs:{id:"四、v8-进行了哪些优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、v8-进行了哪些优化"}},[v._v("#")]),v._v(" 四、v8 进行了哪些优化")]),v._v(" "),t("ul",[t("li",[v._v("JIT：即时编译，编译的结果直接是机器语言，而不是字节码，大大提高了执行效率")]),v._v(" "),t("li",[v._v("垃圾回收：借鉴了 Java VM 的垃圾回收管理")]),v._v(" "),t("li",[v._v("内联缓存：this.a 没有内存缓存的时候每次 a 都会对哈希表进行一次寻址，加入 v8 之后能马上知道这个属性的偏移量")]),v._v(" "),t("li",[v._v("隐藏类")]),v._v(" "),t("li",[v._v("惰性解析：是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码")])])])}),[],!1,null,null,null);_.default=r.exports}}]);